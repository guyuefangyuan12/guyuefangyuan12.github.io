<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>test</title>
    <link href="/2024/07/31/test/"/>
    <url>/2024/07/31/test/</url>
    
    <content type="html"><![CDATA[<h1 id="leetcode"><a href="#leetcode" class="headerlink" title="leetcode"></a>leetcode</h1><ul><li>快速幂</li></ul><p>普通的幂运算每次只只乘上一次，比如计算<code>pow(2,64)</code>就要循环64次。这样的时间复杂度很高，而快速幂则可以减少运算的复杂度</p><p>对于快速幂算法而言，<code>pow(x,y)</code>,我们可以把<code>y</code>看成一个二进制数,然后我们以次求出<code>pow(x,1)</code>,<code>pow(x,2)</code>,<code>pow(x,4)</code>,…以此类推，然后我们查看<code>y</code>对应二进制数的每一位，如果为0,则当前数就要乘上<code>x</code>对应二进制的幂。</p><p>例如<code>y=13</code>,它对应的二进制数为<code>1101</code>,则<code>pow(x,13)</code>就为<code>pow(x,8)</code>、<code>pow(x,4)</code>、<code>pow(x,1)</code>之和。</p><ul><li>算法对应的C++代码</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fastpow</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> ans = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (y) <br>&#123;<br><span class="hljs-keyword">if</span> (y &amp; <span class="hljs-number">1</span>) <br>&#123;<br>ans *= x;<br>&#125;<br>x *= x;<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>关于取余的一些技巧 </p><ul><li>加法取余</li></ul><p><code>(a+b)%c=((a%c)+(b%c))%c</code></p><p>适合与很多个数相加时，最后的很大，无法存下，就将取余操作放在每次相加后，避免数据过大溢出</p><ul><li>乘法取余<br><code>(a*b)%c=((a*c)+(b*c))%c</code></li></ul><p>同样也是为了避免相乘后数据溢出，就将取余操作放在每次相乘之后</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>快速幂</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
