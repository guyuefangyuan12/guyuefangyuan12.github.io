<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>路由分组</title>
    <link href="/2024/08/02/%E8%B7%AF%E7%94%B1%E5%88%86%E7%BB%84/"/>
    <url>/2024/08/02/%E8%B7%AF%E7%94%B1%E5%88%86%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><p>今天开始学习计算机网络，目前都是一些概念，而且比较老</p><h2 id="链路媒介"><a href="#链路媒介" class="headerlink" title="链路媒介"></a>链路媒介</h2><ul><li>双绞线<blockquote><p>适用用于较短距离的网络通信，在进行网络接入时，同家庭的电话线路一起使用，在向网络提供商传输时，把上行信号、下行信号以及语音信号进行频分复用以及编码，在网络供应商端进行解码和信号分离。</p></blockquote></li><li>同轴电缆<blockquote><p>同样适用短距离传输，在网络接入时利用电视信号线，同样也和双绞线一样有一个编码系统进行信号编码与分离。与双绞线不同的是，同轴电缆的信号传输在整个线路上是都可以看到的，有用户A发送的信号会被线路上的其他用户接收到。</p></blockquote></li><li>光纤<blockquote><p>光纤由于其配套设备的成本因素，适用于远距离网络通信。</p></blockquote></li><li>无线媒介<blockquote><p>适用移动网接入，使用电磁波作为媒介，传输距离远，有穿透性。</p></blockquote></li></ul><h2 id="LAN"><a href="#LAN" class="headerlink" title="LAN"></a>LAN</h2><p>目前大部分情况都属于LAN，在家庭、学校、公司使用WIFI等类似设备将所有的端系统的网络接入口汇聚到一起，然后使用光纤等链路连接到网络提供商。</p><h2 id="网络组成"><a href="#网络组成" class="headerlink" title="网络组成"></a>网络组成</h2><p>计算机网络的组成就是端系统(主机)通过一系列交换机和路由器相互连接和传输信息。</p><p>端系统(主机)分为两类</p><ul><li>用户</li><li>服务器</li></ul><h2 id="链路传输"><a href="#链路传输" class="headerlink" title="链路传输"></a>链路传输</h2><p>一个基本的网络组成就是两个端系统通过一个路由器连接起来。</p><p>网络间传输的信息被称为<strong>报文</strong>，但由于一般报文比较大，需要分为更小的部分传输，称为<strong>分组</strong>。</p><p>路由器的传输分组的过程称为<strong>存储转发</strong>，当一个分组的部分信息被传输到路由器时，路由器不会立刻通过转发链路转发，而是会在路由器里存储起来，只有一个分组被全部接收后，才会被路由器转发。</p><p>当主机A向路由器传输一组长度为<strong>L</strong><code>bit</code>的分组，路由器输入链路的传输速率为<strong>R</strong><code>bit/s</code>,转发链路的速率也为<strong>R</strong><code>bit/s</code>。那么这个分组从主机A开始传输，到路由器接收这个分组所需时间为<code>L/R</code>。同理，从路由器开始转发，到主机B接收完这个分组，所需时间也为<code>L/R</code>，因此一个报文从主机A传输到主机B的时间为<code>2L/R</code>.这个时间也被称为<strong>传输延迟</strong>。</p><p>如果有N个分组需要传输，当第一个分组传输到主机B时，第二个报文刚好被路由器接收完毕，因此当N个分组都被接收的传输延迟为<code>(N+1)L/R</code>.</p><p>如果主机A和B之间有<code>N-1</code>个路由器，总共有有<code>N</code>个通信链路，则传输一个分组的传输延迟为<code>NL/R</code>。</p><p>在实际的网络中，一个路由器有多条输入链路和多个转发链路，那如何确定一个分组通过哪个转发链路传输呢？</p><blockquote><p>在分组传输时，分组中包含了前往目的主机的IP地址，路由器通过解析这个IP地址，而路由器会对IP地址和转发链路之间建立一个路由表，从而保证传输的准确无误。</p><p>路由器根据目的主机的IP的转发分组类似与一个问路的过程，IP地址就是XX省XX市XX县XX镇。省级的路由器首先根据省的信息让其进入对应的省，市级的路由器首先根据市的信息让其进入对应的市，以此类推。</p></blockquote><p>如果路由器存储的分组信息超过了转发链路的容量时，就会有一部分分组不能立刻转发，需要排队等前面的分组转发完后才能转发，就这造成了<strong>拥塞</strong>,这个造成的延迟称为<strong>排队延迟</strong>。</p><p>还有一种分组转发方式称为电路转发，他是在两个端系统之间建立实际的连接，路由器会为这种链路预留容量，如果这条链路没有使用，那么这部分容量就被浪费掉，但不会出现排队的情况，因为每条转发链路都有自己的通道，不用挤占其他链路。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>今天没怎么学习，就看了一点内容，大部分时间都在看小说，真是怠惰的一天。</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>直角三角形</title>
    <link href="/2024/08/02/%E7%9B%B4%E8%A7%92%E4%B8%89%E8%A7%92%E5%BD%A2/"/>
    <url>/2024/08/02/%E7%9B%B4%E8%A7%92%E4%B8%89%E8%A7%92%E5%BD%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="leetcode"><a href="#leetcode" class="headerlink" title="leetcode"></a>leetcode</h1><p> 题目：</p><p>给你一个二维 <code>boolean </code>矩阵 <code>grid </code>。请你返回使用<code> grid</code> 中的 3 个元素可以构建的 直角三角形 数目，且满足 3 个元素值 都 为 1 。</p><ul><li>如果 grid 中 3 个元素满足：一个元素与另一个元素在 同一行，同时与第三个元素在 同一列 ，那么这 3 个元素称为一个 直角三角形 。这 3 个元素互相之间不需要相邻。</li><li><code>1 &lt;= grid.length &lt;= 1000</code></li><li><code>1 &lt;= grid[i].length &lt;= 1000</code></li><li><code>0 &lt;= grid[i][j] &lt;= 1</code></li></ul><p>看完题目，就有了思路，统计每行每列<code>1</code>的个数，然后遍历整个<code> grid</code>数组，当当前点<code> grid[i][j]</code>为<code>1</code>时，以当前点为直第<code>i</code>行<code>1</code>的个数减去1角三角形的两个边的交汇点，那么以这个点可以组成的三角形个数为第<code>j</code>列<code>1</code>的个数减去1然后乘上第<code>i</code>行<code>1</code>的个数减去1。然后求和即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) <br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) <br>    &#123;<br>        <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">1</span>) <br>        &#123;<br>            row[i]++;<br>            column[j]++;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span>  ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">1</span>)<br>        &#123;<br>            ans += (row[i] - <span class="hljs-number">1</span>) * (column[j] - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>今天这道题很简单，只需要相同如何判断三角形是否存在即可。</p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排列组合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>心算挑战</title>
    <link href="/2024/08/01/%E5%BF%83%E7%AE%97%E6%8C%91%E6%88%98/"/>
    <url>/2024/08/01/%E5%BF%83%E7%AE%97%E6%8C%91%E6%88%98/</url>
    
    <content type="html"><![CDATA[<h1 id="leetcode"><a href="#leetcode" class="headerlink" title="leetcode"></a>leetcode</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>从 N 张卡牌中选出 <code>cnt</code>张卡牌，若这<code>cnt</code>张卡牌数字总和为偶数，则选手成绩「有效」且得分为<code>cnt</code>张卡牌数字总和。 给定数组<code>cards</code>和<code> cnt</code>，其中<code>cards[i]</code>表示第<code>i</code>张卡牌上的数字。 请帮参赛选手计算最大的有效得分。若不存在获取有效得分的卡牌方案，则返回 0。</p><p>当我看到这个题目时，第一个想法是记忆化递归，因此开始对题目进行分析。</p><p>首先，题目可以看成是在<code>0</code>-<code>n-1</code>这<code>n</code>个数中选择<code>cnt</code>个数，使其和为偶数且最大。因此对第<code>n-1</code>个数有以下两种选择</p><ul><li>选择第<code>n-1</code>个数<ul><li>如果<code>cards[n-1]</code>为偶数，则问题就变为在<code>0</code>-<code>n-2</code>这<code>n-1</code>个数中选择<code>cnt-1</code>个数，使其和为偶数且最大。</li><li>如果<code>cards[n-1]</code>为奇数，则问题就变为在<code>0</code>-<code>n-2</code>这<code>n-1</code>个数中选择<code>cnt-1</code>个数，使其和为奇数且最大。</li></ul></li><li>不选择第<code>n-1</code>个数，则问题就变为在<code>0</code>-<code>n-2</code>这<code>n-1</code>个数中选择<code>cnt</code>个数，使其和为偶数且最大。</li></ul><p>因此这个问题就变为了在<code>0</code>-<code>i</code>这<code>i+1</code>个数中选择<code>j</code>个数，使其和为偶数&#x2F;奇数且最大。然后对这个问题进行递归即可。</p><p>因此定义<code>dfs(i,j,k)</code>为递归函数，当<code>k</code>为0时，表示要和为偶数，为<code>1</code>时，表示和要为奇数，返回值为在<code>0</code>-<code>i</code>这<code>i+1</code>个数中选择<code>j</code>个数，使其和为偶数&#x2F;奇数时的最大值。</p><p>递归边界为<code>i</code>&lt;0,返回值为0.</p><p>递归关系式为</p><ul><li><code>j</code>&gt;1<br><code>dfs(i,j,k) = max(dfs(i-1,j,k), dfs(i-1, j-1, (k+cards[i]) % 2) ? dfs(i-1, j-1, (k+cards[i]) % 2)+cards[i] : 0</code></li><li><code>j</code>&#x3D;1<br><code>cards[i] % 2 == k ? cards[i] : dfs(i - 1, j, k)</code>(已经对<code>cards</code>进行过排序)</li></ul><p>最后返回的结果为<code>dfs(n - 1, cnt, 0)</code>.</p><p>然后是对递归记忆化，避免多次计算同一入口条件，最开始使用3位数组<code>cache[i][j][k]</code>进行记忆，但这个数组有很多空间是没有被利用的。于是采用<code>unordered_map&lt;long long, int&gt; cache</code>进行记忆，其<code>key</code>为<code>long long key = k | i &lt;&lt; 1 | j &lt;&lt; 20</code>.</p><p>尽管这样，但最后运行结果超时，表明这种做法不可行。</p><ul><li><code>dfs</code>代码<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++">function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; dfs = [&amp;](<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> k)-&gt;<span class="hljs-type">int</span><br>&#123;<br><span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> flag = k | i &lt;&lt; <span class="hljs-number">1</span> | j &lt;&lt; <span class="hljs-number">20</span>;<br><span class="hljs-keyword">if</span> (!cache.<span class="hljs-built_in">count</span>(flag))<br>&#123;<br><span class="hljs-keyword">if</span> (j == <span class="hljs-number">1</span>)<br>&#123;<br>cache[flag] = (cards[i] % <span class="hljs-number">2</span> == k ? cards[i] : <span class="hljs-built_in">dfs</span>(i - <span class="hljs-number">1</span>, j, k));<br><span class="hljs-keyword">return</span> cache[flag];<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>cache[flag] = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">dfs</span>(i - <span class="hljs-number">1</span>, j, k), <span class="hljs-built_in">dfs</span>(i - <span class="hljs-number">1</span>, j - <span class="hljs-number">1</span>, (k + cards[i]) % <span class="hljs-number">2</span>) ? <span class="hljs-built_in">dfs</span>(i - <span class="hljs-number">1</span>, j - <span class="hljs-number">1</span>, (k + cards[i]) % <span class="hljs-number">2</span>) + cards[i] : <span class="hljs-number">0</span>);<br><span class="hljs-keyword">return</span> cache[flag];<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">return</span> cache[flag];<br>&#125;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><p>虽然使用dp不会成功，但已经写出来记忆化递归了，那顺便把dp也写出来吧。</p><p>dp的核心递归公式和dfs一致，只是要把dfs替换成dp数组，然后边界条件是<code>j=1</code>时的情况，然后就是dp要从<code>i=1</code>开始计算所以奇数和偶数情况在每次循环时都要计算。最终结果为<code>dp[0 | (n - 1) &lt;&lt; 1 | cnt &lt;&lt; 20]</code></p><ul><li>dp代码<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>&#123;<br>dp[(cards[i] % <span class="hljs-number">2</span>) | i &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">20</span>] = <span class="hljs-built_in">max</span>(cards[i], dp[(cards[i] % <span class="hljs-number">2</span>) | (i - <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">20</span>]);<br>dp[((cards[i] + <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>) | i &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">20</span>] = dp[((cards[i] + <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>) | (i - <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">20</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">2</span>; j &lt;= i + <span class="hljs-number">1</span> &amp;&amp; j &lt;= cnt; j++)<br>&#123;<br>dp[<span class="hljs-number">0</span> | i &lt;&lt; <span class="hljs-number">1</span> | j &lt;&lt; <span class="hljs-number">20</span>] = <span class="hljs-built_in">max</span>(dp[<span class="hljs-number">0</span> | (i - <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-number">1</span> | j &lt;&lt; <span class="hljs-number">20</span>], dp[cards[i] % <span class="hljs-number">2</span> | (i - <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-number">1</span> | (j - <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-number">20</span>] ? dp[cards[i] % <span class="hljs-number">2</span> | (i - <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-number">1</span> | (j - <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-number">20</span>] + cards[i] : <span class="hljs-number">0</span>);<br>dp[<span class="hljs-number">1</span> | i &lt;&lt; <span class="hljs-number">1</span> | j &lt;&lt; <span class="hljs-number">20</span>] = <span class="hljs-built_in">max</span>(dp[<span class="hljs-number">1</span> | (i - <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-number">1</span> | j &lt;&lt; <span class="hljs-number">20</span>], dp[(cards[i] + <span class="hljs-number">1</span>) % <span class="hljs-number">2</span> | (i - <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-number">1</span> | (j - <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-number">20</span>] ? dp[(cards[i] + <span class="hljs-number">1</span>) % <span class="hljs-number">2</span> | (i - <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-number">1</span> | (j - <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-number">20</span>] + cards[i] : <span class="hljs-number">0</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>然后查看提示，发现要使用贪心和排序。经过思考后决定先将数组排序，然后将其分为奇偶两个数组。然后在进行判断。</p><p>在进行判断时要分为多种情况讨论，<code>s_max</code>,<code>d_max1</code>,<code>d_max2</code>分别为最大两个奇数的和，最大的偶数以及最大两个偶数的和。<code>s_pos</code>,<code>d_pos</code>分别表示还未使用的最大奇数下标以及还未使用的最大偶数下标。</p><p>以下是几种需要讨论的情况</p><ul><li><code>cnt</code>为1时，需要判断是否还有偶数</li><li>只剩两个偶数时</li><li>只剩一个偶数时</li><li>没有偶数时</li><li>偶数数量大于2时（这是一般情况，只需要比较<code>s_max</code>,<code>d_max1</code>,<code>d_max2</code>的大小进行判断即可）</li></ul><p>其他特殊情况需要综合还未使用的奇数数量，还未使用的偶数数量以及还有多少的数没有选择。</p><ul><li>奇偶数组的判断代码<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span> (cnt)<br>&#123;<br><span class="hljs-type">int</span> s_max = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> d_max1 = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> d_max2 = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (cnt == <span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-keyword">if</span> (d_pos &gt;= <span class="hljs-number">0</span>)<br>&#123;<br>ans += d[d_pos];<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>ans = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (s_pos &gt; <span class="hljs-number">0</span>)<br>&#123;<br>s_max = s[s_pos] + s[s_pos - <span class="hljs-number">1</span>];<br>&#125;<br><span class="hljs-keyword">if</span> (d_pos &gt; <span class="hljs-number">1</span>)<br>&#123;<br>d_max1 = d[d_pos];<br>d_max2 = d[d_pos] + d[d_pos - <span class="hljs-number">1</span>];<br><span class="hljs-keyword">if</span> (d_max1 &gt;= s_max)<br>&#123;<br>ans += d_max1;<br>d_pos--;<br>cnt--;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (d_max2 &gt; s_max)<br>&#123;<br>ans += d_max2;<br>d_pos -= <span class="hljs-number">2</span>;<br>cnt -= <span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>ans += s_max;<br>s_pos -= <span class="hljs-number">2</span>;<br>cnt -= <span class="hljs-number">2</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (d_pos == <span class="hljs-number">1</span>)<br>&#123;<br>d_max1 = d[d_pos];<br>d_max2 = d[d_pos] + d[d_pos - <span class="hljs-number">1</span>];<br><span class="hljs-keyword">if</span> (s_max &gt; d_max2)<br>&#123;<br>ans += s_max;<br>s_pos -= <span class="hljs-number">2</span>;<br>cnt -= <span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (d_max1 &gt;= s_max)<br>&#123;<br>ans += d_max1;<br>d_pos--;<br>cnt--;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">if</span> ((cnt - <span class="hljs-number">2</span>) % <span class="hljs-number">2</span>)<br>&#123;<br>ans += d_max1;<br>d_pos--;<br>cnt--;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">if</span> (cnt - <span class="hljs-number">2</span> &lt;= s_pos + <span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = s_pos; i &gt;= s_pos + <span class="hljs-number">3</span> - cnt; i--)<br>&#123;<br>ans += s[i];<br>&#125;<br>ans += d_max2;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (d_pos == <span class="hljs-number">0</span>)<br>&#123;<br>d_max1 = d[d_pos];<br><span class="hljs-keyword">if</span> (s_max &gt; d_max1)<br>&#123;<br>ans += s_max;<br>s_pos -= <span class="hljs-number">2</span>;<br>cnt -= <span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">if</span> ((cnt - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>)<br>&#123;<br><span class="hljs-keyword">if</span> (cnt &lt;= s_pos + <span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = s_pos; i &gt;= s_pos + <span class="hljs-number">1</span> - cnt; i--)<br>&#123;<br>ans += s[i];<br>&#125;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">if</span> (cnt - <span class="hljs-number">1</span> &lt;= s_pos + <span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = s_pos; i &gt;= s_pos + <span class="hljs-number">2</span> - cnt; i--)<br>&#123;<br>ans += s[i];<br>&#125;<br>ans += d_max1;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (d_pos &lt; <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">if</span> (cnt % <span class="hljs-number">2</span>)<br>&#123;<br>ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">if</span> (cnt &lt;= s_pos + <span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = s_pos; i &gt;= s_pos + <span class="hljs-number">1</span> - cnt; i--)<br>&#123;<br>ans += s[i];<br>&#125;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>这个思路比较容易想到，但其特殊情况很多，需要经过很多判断，非常烦人，很容易出现一望一些特殊情况。</p><p>查看题解后，发现了一个更加简单的方法，不需要考虑很多特殊情况。</p><p>首先将数组进行排序，然后取最大的<code>cnt</code>个数相加得到<code>ans</code>.然后根据<code>ans</code>进行判断</p><ul><li>如果<code>ans</code>为偶数，则直接返回</li><li>如果<code>ans</code>为奇数，则有以下两种情况<ul><li><code>ans</code>减去已使用过数中的最小偶数，加上一个未使用过的最大奇数</li><li><code>ans</code>减去已使用过数中的最小奇数，加上一个未使用过的最大偶数<br>将以上两种情况得到的值取最大即为<code>ans</code>，但以上两种不一定都会出现，需要进行判断，如果两种情况都不出现，则没有符合条件的结果，返回0.</li></ul></li></ul><p>以下代码中<code>pos1</code>,<code>pos2</code>分别为已使用过的数中最小奇数和最小偶数的下标，<code>pos3</code>,<code>pos4</code>分别为未使用过的数中最大奇数和最大偶数的下标。如果下标值为<code>n</code>,则表明不存在这样的数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= n  - cnt; i--)<br>&#123;<br><span class="hljs-keyword">if</span> (cards[i] % <span class="hljs-number">2</span>)<br>&#123;<br>pos1 = i;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>pos2 = i;<br>&#125;<br>ans += cards[i];<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span> - cnt; i &gt;= <span class="hljs-number">0</span>; i--)<br>&#123;<br><span class="hljs-keyword">if</span> ((cards[i] % <span class="hljs-number">2</span>) &amp;&amp; pos3 == n)<br>&#123;<br>pos3 = i;<br>&#125;<br><span class="hljs-keyword">if</span> (!(cards[i] % <span class="hljs-number">2</span>) &amp;&amp; pos4 == n)<br>&#123;<br>pos4 = i;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (ans % <span class="hljs-number">2</span>)<br>&#123;<br><span class="hljs-keyword">if</span> (pos3 == n)<br>&#123;<br><span class="hljs-keyword">if</span> (pos4 == n)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>ans = ans - cards[pos1] + cards[pos4];<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">if</span> (pos4 == n)<br>&#123;<br><span class="hljs-keyword">if</span> (pos2 != n)<br>&#123;<br>ans = ans - cards[pos2] + cards[pos3];<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">if</span> (pos2 != n)<br>&#123;<br>ans = <span class="hljs-built_in">max</span>(ans - cards[pos2] + cards[pos3], ans - cards[pos1] + cards[pos4]);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>ans = ans - cards[pos1] + cards[pos4];<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本来是一道简单题，但是想的太多，反而使其变得更加复杂。（ps:这是第二次打完这段文字，第一次没有保存，导致多花了一个小时，真是糟糕的一天）</p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快速幂</title>
    <link href="/2024/07/31/%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    <url>/2024/07/31/%E5%BF%AB%E9%80%9F%E5%B9%82/</url>
    
    <content type="html"><![CDATA[<h1 id="leetcode"><a href="#leetcode" class="headerlink" title="leetcode"></a>leetcode</h1><ul><li>快速幂</li></ul><p>普通的幂运算每次只只乘上一次，比如计算<code>pow(2,64)</code>就要循环64次。这样的时间复杂度很高，而快速幂则可以减少运算的复杂度</p><p>对于快速幂算法而言，<code>pow(x,y)</code>,我们可以把<code>y</code>看成一个二进制数,然后我们以次求出<code>pow(x,1)</code>,<code>pow(x,2)</code>,<code>pow(x,4)</code>,…以此类推，然后我们查看<code>y</code>对应二进制数的每一位，如果为0,则当前数就要乘上<code>x</code>对应二进制的幂。</p><p>例如<code>y=13</code>,它对应的二进制数为<code>1101</code>,则<code>pow(x,13)</code>就为<code>pow(x,8)</code>、<code>pow(x,4)</code>、<code>pow(x,1)</code>之和。</p><ul><li>算法对应的C++代码</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fastpow</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> ans = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (y) <br>&#123;<br><span class="hljs-keyword">if</span> (y &amp; <span class="hljs-number">1</span>) <br>&#123;<br>ans *= x;<br>&#125;<br>x *= x;<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>关于取余的一些技巧 </p><ul><li>加法取余</li></ul><p><code>(a+b)%c=((a%c)+(b%c))%c</code></p><p>适合与很多个数相加时，最后的很大，无法存下，就将取余操作放在每次相加后，避免数据过大溢出</p><ul><li>乘法取余</li></ul><p><code>(a*b)%c=((a*c)+(b*c))%c</code></p><p>同样也是为了避免相乘后数据溢出，就将取余操作放在每次相乘之后</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>快速幂</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
