<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>因特网5层网络模型</title>
    <link href="/2024/08/03/%E5%9B%A0%E7%89%B9%E7%BD%915%E5%B1%82%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/"/>
    <url>/2024/08/03/%E5%9B%A0%E7%89%B9%E7%BD%915%E5%B1%82%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h1><p>电路交换是不同于分组交换的一种交换方式。</p><p>电路交换在计算机网络中主要采用一下两种方式，频分复用（FDM）和时分复用（TDM）</p><ol><li>频分复用<blockquote><p>频分复用就是这个网络传输的总带宽为<code>B</code>，如果主机A与主机B之间存在<code>N</code>条链路，如果为每条链路分配同样的资源，那么每条链路就会占用<code>B/N</code>宽的频带来传输分组</p><p>如下图所示,整个网络带宽为20，总共有5条链路，每条链路占用4</p><p><img src="/2024/08/03/%E5%9B%A0%E7%89%B9%E7%BD%915%E5%B1%82%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/%E9%A2%91%E5%88%86%E5%A4%8D%E7%94%A8.png" alt="频分复用"></p></blockquote></li><li>时分复用<blockquote><p>时分复用就是将整个网络的传输资源为1帧，每一帧又划分为多个时隙，每个链路占据一定的时隙用来传输分组。</p><p>如下图所示，一帧被分为4个时隙，分别被4条链路占据。</p><p><img src="/2024/08/03/%E5%9B%A0%E7%89%B9%E7%BD%915%E5%B1%82%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/%E6%97%B6%E5%88%86%E5%A4%8D%E7%94%A8.png" alt="时分复用"></p></blockquote></li></ol><p>电路交换和分组交换的比较</p><blockquote><p>电路交换和分组交换比起来，它会预先为每条链路预留资源，不管这条链路是否被使用，这些资源都会被使用，这样当一些链路不工作时，就会造成资源的浪费。但比起分组交换，他的传输延迟会较小，因为电路交换存在确定的链路，它不需要在路由器里等待存储。同时电路交换不会因为一条链路上需要传输的资源过多，导致其他链路也被拥塞</p><p>但在分组交换中，因为不会出现所有的链路都在活跃的情况，因此分组交换在大多数情况下，能表现出比电路交换更好性能。</p><p>电路交换就是一种固定分配资源的交换方式，而分组交换是一种按需分配资源的交换方式。从目前来看，分组交换是一种更普遍的方式</p></blockquote><h1 id="网络的结构"><a href="#网络的结构" class="headerlink" title="网络的结构"></a>网络的结构</h1><p>目前的因特网的网络结构包括如下组成</p><ul><li>接入ISP<blockquote><p>接入ISP就是端系统或者主机，位于网络结构的底层</p></blockquote></li><li>区域ISP<blockquote><p>位于网络结构中间层的ISP提供者</p></blockquote></li><li>第一级ISP<blockquote><p>全球传输的ISP</p></blockquote></li><li>多宿<blockquote><p>一个ISP可以有多个ISP提供者，保证在一个ISP提供者出错时，网络能正常运行</p></blockquote></li><li>对等<blockquote><p>位于同一层次的临近ISP可以直接相连，他们彼此可以相互传输流量而不必付费(ISP客户向ISP提供者传输流量时需要付费)</p></blockquote></li><li>IXP<blockquote><p>IXP是一个交汇点，使不同层次的ISP对等</p></blockquote></li><li>内容提供者<blockquote><p>内容提供者位于最顶层，它相当于一个大型的服务器用来提供服务，他与第一级的ISP相连，并且传输时会付费，但它通过IXP相连的下级ISP就不必付费</p></blockquote></li></ul><p>下图是一个网络结构</p><p><img src="/2024/08/03/%E5%9B%A0%E7%89%B9%E7%BD%915%E5%B1%82%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84.jpg" alt="网络结构"></p><h1 id="时延和吞吐量"><a href="#时延和吞吐量" class="headerlink" title="时延和吞吐量"></a>时延和吞吐量</h1><p>端到端的时延包括以下几类</p><ul><li>处理时延<blockquote><p>在路由器节点的检查分组首部以及决定分组导向何处的时延</p></blockquote></li><li>传输时延<blockquote><p>节点将分组全部传输到链路的时间，如果分组长度为<code>L</code>,链路传输速率为<code>R</code>，则传输时延为<code>L/R</code>。</p></blockquote></li><li>传播时延<blockquote><p>分组从链路起点到链路终点的传播时间，如果链路长度为<code>d</code>,链路传播速率为<code>v</code>，则传播时延为<code>d/v</code></p></blockquote></li><li>排队时延<blockquote><p>分组因为拥塞原因，在路由器节点里面等待传输而造成的时延</p></blockquote></li></ul><p>传输时延和传播时延的比较</p><blockquote><p>传输时延相当于是节点把分组运送到链路的时间，传播时延是分组在链路上传输的时间，传输时延与分组长度和传输速率相关，而传播时延与链路长度和传输介质相关。</p></blockquote><p>流量强度</p><blockquote><p><code>a</code>表示分到达队列的平均速率，则<code>La/R</code>为流量强度,如果<code>La/R</code>大于1，表明分组的到达速率大于分组的转发速率，这样会导致排队队列无线加长，<code>La/R</code>&lt;1这时的排队队列就会缩短。</p><p>当流量强度在长时间内大于1时，排队队列超出路由器的缓存队列时就会导致丢包。</p></blockquote><p>吞吐量</p><blockquote><p>两个端系统之间的吞吐量取决于他们之间链路的最小传输速率。</p></blockquote><h1 id="5层网络模型"><a href="#5层网络模型" class="headerlink" title="5层网络模型"></a>5层网络模型</h1><p>5层网络模型包括以下5层</p><ul><li>应用层<blockquote><p>应用层主要端系统上的应用服务程序，这一层主要使用的协议为HTTP(web文档)、SMTP(邮件)、FTP(文件传输)，这一层传输的分组被称为报文</p></blockquote></li><li>运输层<blockquote><p>运输层获取应用层报文，并加上运输层首部，形成这一层的分组，被称为报文段，这一层的协议只要有TCP和UDP</p></blockquote></li><li>网络层<blockquote><p>网络层把从运输层的报文段，加上网络层首部，形成这一层的分组，被称为数据报，这一层的协议只要有IP协议</p></blockquote></li><li>链路层<blockquote><p>网络层把从链路层的数据报，加上链路层首部，形成这一层的分组，被称为帧，这一层的协议只要有DOCSIS协议。</p></blockquote></li><li>物理层<blockquote><p>物理层的作用是把帧的一个个bit传输到下一个节点，该层的协议与传输所用的媒介有关。</p></blockquote></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>正方形中的最多点数</title>
    <link href="/2024/08/03/%E6%AD%A3%E6%96%B9%E5%BD%A2%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%9A%E7%82%B9%E6%95%B0/"/>
    <url>/2024/08/03/%E6%AD%A3%E6%96%B9%E5%BD%A2%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%9A%E7%82%B9%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="leetcode"><a href="#leetcode" class="headerlink" title="leetcode"></a>leetcode</h1><p>题目：</p><blockquote><p>给你一个二维数组<code>points</code> 和一个字符串<code>s</code>，其中<code>points[i]</code>表示第 i 个点的坐标，<code>s[i]</code>表示第<code>i</code>个点的 标签 。</p><p>如果一个正方形的中心在<code>(0, 0)</code>，所有边都平行于坐标轴，且正方形内不存在标签相同的两个点，那么我们称这个正方形是合法的。</p><p>请你返回合法正方形中可以包含的最多点数。</p></blockquote><blockquote><p>注意：</p><ul><li>如果一个点位于正方形的边上或者在边以内，则认为该点位于正方形内。</li><li>正方形的边长可以为零。<br>提示：</li><li><code>1 &lt;= s.length, points.length &lt;= 10^5</code></li><li><code>points[i].length == 2</code></li><li><code>-10^9 &lt;= points[i][0], points[i][1] &lt;= 10^9</code></li><li><code>s.length == points.length</code></li><li><code>points</code> 中的点坐标互不相同。</li><li><code>s</code>只包含小写英文字母。</li></ul></blockquote><p>看到题目后。想到的第一种方法时，遍历<code>points</code>数组，然后将其中的点<code>points[i]</code>与<code>(0, 0)</code>的<strong>切比雪夫距离</strong>(<code>max(abs(points[i][0]), abs(points[i][1])</code>)作为下标，将<code>s[i]</code>作为值存储到一个二维数组<code>count</code>中。</p><p>在遍历完<code>points</code>数组后，从小到大遍历<code>count</code>，同时定义一个<code>visit</code>数组，用于表示标签是否在正方形。在<code>count[i]</code>中查看每个标签是否在正方形中，如果遍历完没有重复的标签，就将<code>cnt</code>加一，如果有重复就退出循环。然后返回<code>cnt</code>。</p><p>但因为<code>-10^9 &lt;= points[i][0], points[i][1] &lt;= 10^9</code>，测存储需要的空间太多。</p><p>然后想到标签只有26个，因此可以用标签作为下标，切比雪夫距离作为值存储到一个二维数组<code>count</code>中，当遍历完<code>points</code>数组后，将<code>count[i]</code>按从小到大排序，然后比较<code>count[i][0]</code>和<code>count[i][1]</code>，先定义一个<code>Max</code>,代表合法正方形的最大的边长的一半需要小于<code>Max</code>。如果两者相等，则合<code>Max</code>为<code>max(Max,count[i][1])</code>，如果两者不等，则<code>Max</code>为<code>max(Max,count[i][1])</code>.然后在遍历<code>count[i][0]</code>，如果<code>count[i][0]</code>小于<code>Max</code>，则<code>cnt</code>加一。最后返回<code>cnt</code>。</p><p>然后再写代码时发现，最后的比较阶段只利用了<code>count[i][0]</code>和<code>count[i][1]</code>，也就是最小切比雪夫距离和次小切比雪夫距离。然后再求<code>Max</code>时，可以直接<code>max(Max,count[i][1])</code>，因为两者相等时，<code>count[i][0]</code>和<code>count[i][1]</code>大小一致。</p><ul><li>c++代码<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">count</span>(<span class="hljs-number">26</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>,INT_MAX));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) <br>        &#123;<br>            <span class="hljs-type">int</span> temp = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">abs</span>(points[i][<span class="hljs-number">0</span>]), <span class="hljs-built_in">abs</span>(points[i][<span class="hljs-number">1</span>]));<br>            <span class="hljs-keyword">if</span> (temp &lt; count[s[i] - <span class="hljs-string">&#x27;a&#x27;</span>][<span class="hljs-number">0</span>]) <br>            &#123;<br>                count[s[i] - <span class="hljs-string">&#x27;a&#x27;</span>][<span class="hljs-number">1</span>] = count[s[i] - <span class="hljs-string">&#x27;a&#x27;</span>][<span class="hljs-number">0</span>];<br>                count[s[i] - <span class="hljs-string">&#x27;a&#x27;</span>][<span class="hljs-number">0</span>] = temp;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (temp &lt; count[s[i] - <span class="hljs-string">&#x27;a&#x27;</span>][<span class="hljs-number">1</span>])<br>            &#123;<br>                count[s[i] - <span class="hljs-string">&#x27;a&#x27;</span>][<span class="hljs-number">1</span>] = temp;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> m = INT_MAX;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) <br>        &#123;<br>            m = <span class="hljs-built_in">min</span>(m, count[i][<span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (count[i][<span class="hljs-number">0</span>] &lt; m) <br>            &#123;<br>                ans++;<br>            &#125;<br>        &#125;<br></code></pre></td></tr></table></figure></li></ul><p>再查看题解后还有一种思路是二分查找。</p><p>通过二分正方形的边长，每次遍历整个<code>points</code>,如果<code>points[i]</code>不在正方形内，则退出，更新二分的<code>left</code>和<code>right</code>.</p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二分查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>路由交换</title>
    <link href="/2024/08/02/%E8%B7%AF%E7%94%B1%E5%88%86%E7%BB%84/"/>
    <url>/2024/08/02/%E8%B7%AF%E7%94%B1%E5%88%86%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><p>今天开始学习计算机网络，目前都是一些概念，而且比较老</p><h2 id="链路媒介"><a href="#链路媒介" class="headerlink" title="链路媒介"></a>链路媒介</h2><ul><li>双绞线<blockquote><p>适用用于较短距离的网络通信，在进行网络接入时，同家庭的电话线路一起使用，在向网络提供商传输时，把上行信号、下行信号以及语音信号进行频分复用以及编码，在网络供应商端进行解码和信号分离。</p></blockquote></li><li>同轴电缆<blockquote><p>同样适用短距离传输，在网络接入时利用电视信号线，同样也和双绞线一样有一个编码系统进行信号编码与分离。与双绞线不同的是，同轴电缆的信号传输在整个线路上是都可以看到的，有用户A发送的信号会被线路上的其他用户接收到。</p></blockquote></li><li>光纤<blockquote><p>光纤由于其配套设备的成本因素，适用于远距离网络通信。</p></blockquote></li><li>无线媒介<blockquote><p>适用移动网接入，使用电磁波作为媒介，传输距离远，有穿透性。</p></blockquote></li></ul><h2 id="LAN"><a href="#LAN" class="headerlink" title="LAN"></a>LAN</h2><p>目前大部分情况都属于LAN，在家庭、学校、公司使用WIFI等类似设备将所有的端系统的网络接入口汇聚到一起，然后使用光纤等链路连接到网络提供商。</p><h2 id="网络组成"><a href="#网络组成" class="headerlink" title="网络组成"></a>网络组成</h2><p>计算机网络的组成就是端系统(主机)通过一系列交换机和路由器相互连接和传输信息。</p><p>端系统(主机)分为两类</p><ul><li>用户</li><li>服务器</li></ul><h2 id="链路传输"><a href="#链路传输" class="headerlink" title="链路传输"></a>链路传输</h2><p>一个基本的网络组成就是两个端系统通过一个路由器连接起来。</p><p>网络间传输的信息被称为<strong>报文</strong>，但由于一般报文比较大，需要分为更小的部分传输，称为<strong>分组</strong>。</p><p>路由器的传输分组的过程称为<strong>存储转发</strong>，当一个分组的部分信息被传输到路由器时，路由器不会立刻通过转发链路转发，而是会在路由器里存储起来，只有一个分组被全部接收后，才会被路由器转发。</p><p>当主机A向路由器传输一组长度为<strong>L</strong><code>bit</code>的分组，路由器输入链路的传输速率为<strong>R</strong><code>bit/s</code>,转发链路的速率也为<strong>R</strong><code>bit/s</code>。那么这个分组从主机A开始传输，到路由器接收这个分组所需时间为<code>L/R</code>。同理，从路由器开始转发，到主机B接收完这个分组，所需时间也为<code>L/R</code>，因此一个报文从主机A传输到主机B的时间为<code>2L/R</code>.这个时间也被称为<strong>传输时延</strong>。</p><p>如果有N个分组需要传输，当第一个分组传输到主机B时，第二个报文刚好被路由器接收完毕，因此当N个分组都被接收的传输时延为<code>(N+1)L/R</code>.</p><p>如果主机A和B之间有<code>N-1</code>个路由器，总共有有<code>N</code>个通信链路，则传输一个分组的传输时延为<code>NL/R</code>。</p><p>在实际的网络中，一个路由器有多条输入链路和多个转发链路，那如何确定一个分组通过哪个转发链路传输呢？</p><blockquote><p>在分组传输时，分组中包含了前往目的主机的IP地址，路由器通过解析这个IP地址，而路由器会对IP地址和转发链路之间建立一个路由表，从而保证传输的准确无误。</p><p>路由器根据目的主机的IP的转发分组类似与一个问路的过程，IP地址就是XX省XX市XX县XX镇。省级的路由器首先根据省的信息让其进入对应的省，市级的路由器首先根据市的信息让其进入对应的市，以此类推。</p></blockquote><p>如果路由器存储的分组信息超过了转发链路的容量时，就会有一部分分组不能立刻转发，需要排队等前面的分组转发完后才能转发，就这造成了<strong>拥塞</strong>,这个造成的延迟称为<strong>排队延迟</strong>。</p><p>还有一种分组转发方式称为电路交换，他是在两个端系统之间建立实际的连接，路由器会为这种链路预留容量，如果这条链路没有使用，那么这部分容量就被浪费掉，但不会出现排队的情况，因为每条转发链路都有自己的通道，不用挤占其他链路。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>今天没怎么学习，就看了一点内容，大部分时间都在看小说，真是怠惰的一天。天。</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>直角三角形</title>
    <link href="/2024/08/02/%E7%9B%B4%E8%A7%92%E4%B8%89%E8%A7%92%E5%BD%A2/"/>
    <url>/2024/08/02/%E7%9B%B4%E8%A7%92%E4%B8%89%E8%A7%92%E5%BD%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="leetcode"><a href="#leetcode" class="headerlink" title="leetcode"></a>leetcode</h1><p> 题目：</p><p>给你一个二维 <code>boolean </code>矩阵 <code>grid </code>。请你返回使用<code> grid</code> 中的 3 个元素可以构建的 直角三角形 数目，且满足 3 个元素值 都 为 1 。</p><ul><li>如果 grid 中 3 个元素满足：一个元素与另一个元素在 同一行，同时与第三个元素在 同一列 ，那么这 3 个元素称为一个 直角三角形 。这 3 个元素互相之间不需要相邻。</li><li><code>1 &lt;= grid.length &lt;= 1000</code></li><li><code>1 &lt;= grid[i].length &lt;= 1000</code></li><li><code>0 &lt;= grid[i][j] &lt;= 1</code></li></ul><p>看完题目，就有了思路，统计每行每列<code>1</code>的个数，然后遍历整个<code> grid</code>数组，当当前点<code> grid[i][j]</code>为<code>1</code>时，以当前点为直第<code>i</code>行<code>1</code>的个数减去1角三角形的两个边的交汇点，那么以这个点可以组成的三角形个数为第<code>j</code>列<code>1</code>的个数减去1然后乘上第<code>i</code>行<code>1</code>的个数减去1。然后求和即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) <br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) <br>    &#123;<br>        <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">1</span>) <br>        &#123;<br>            row[i]++;<br>            column[j]++;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span>  ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">1</span>)<br>        &#123;<br>            ans += (row[i] - <span class="hljs-number">1</span>) * (column[j] - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>今天这道题很简单，只需要相同如何判断三角形是否存在即可。</p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排列组合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>心算挑战</title>
    <link href="/2024/08/01/%E5%BF%83%E7%AE%97%E6%8C%91%E6%88%98/"/>
    <url>/2024/08/01/%E5%BF%83%E7%AE%97%E6%8C%91%E6%88%98/</url>
    
    <content type="html"><![CDATA[<h1 id="leetcode"><a href="#leetcode" class="headerlink" title="leetcode"></a>leetcode</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>从 N 张卡牌中选出 <code>cnt</code>张卡牌，若这<code>cnt</code>张卡牌数字总和为偶数，则选手成绩「有效」且得分为<code>cnt</code>张卡牌数字总和。 给定数组<code>cards</code>和<code> cnt</code>，其中<code>cards[i]</code>表示第<code>i</code>张卡牌上的数字。 请帮参赛选手计算最大的有效得分。若不存在获取有效得分的卡牌方案，则返回 0。</p><p>当我看到这个题目时，第一个想法是记忆化递归，因此开始对题目进行分析。</p><p>首先，题目可以看成是在<code>0</code>-<code>n-1</code>这<code>n</code>个数中选择<code>cnt</code>个数，使其和为偶数且最大。因此对第<code>n-1</code>个数有以下两种选择</p><ul><li>选择第<code>n-1</code>个数<ul><li>如果<code>cards[n-1]</code>为偶数，则问题就变为在<code>0</code>-<code>n-2</code>这<code>n-1</code>个数中选择<code>cnt-1</code>个数，使其和为偶数且最大。</li><li>如果<code>cards[n-1]</code>为奇数，则问题就变为在<code>0</code>-<code>n-2</code>这<code>n-1</code>个数中选择<code>cnt-1</code>个数，使其和为奇数且最大。</li></ul></li><li>不选择第<code>n-1</code>个数，则问题就变为在<code>0</code>-<code>n-2</code>这<code>n-1</code>个数中选择<code>cnt</code>个数，使其和为偶数且最大。</li></ul><p>因此这个问题就变为了在<code>0</code>-<code>i</code>这<code>i+1</code>个数中选择<code>j</code>个数，使其和为偶数&#x2F;奇数且最大。然后对这个问题进行递归即可。</p><p>因此定义<code>dfs(i,j,k)</code>为递归函数，当<code>k</code>为0时，表示要和为偶数，为<code>1</code>时，表示和要为奇数，返回值为在<code>0</code>-<code>i</code>这<code>i+1</code>个数中选择<code>j</code>个数，使其和为偶数&#x2F;奇数时的最大值。</p><p>递归边界为<code>i</code>&lt;0,返回值为0.</p><p>递归关系式为</p><ul><li><code>j</code>&gt;1<br><code>dfs(i,j,k) = max(dfs(i-1,j,k), dfs(i-1, j-1, (k+cards[i]) % 2) ? dfs(i-1, j-1, (k+cards[i]) % 2)+cards[i] : 0</code></li><li><code>j</code>&#x3D;1<br><code>cards[i] % 2 == k ? cards[i] : dfs(i - 1, j, k)</code>(已经对<code>cards</code>进行过排序)</li></ul><p>最后返回的结果为<code>dfs(n - 1, cnt, 0)</code>.</p><p>然后是对递归记忆化，避免多次计算同一入口条件，最开始使用3位数组<code>cache[i][j][k]</code>进行记忆，但这个数组有很多空间是没有被利用的。于是采用<code>unordered_map&lt;long long, int&gt; cache</code>进行记忆，其<code>key</code>为<code>long long key = k | i &lt;&lt; 1 | j &lt;&lt; 20</code>.</p><p>尽管这样，但最后运行结果超时，表明这种做法不可行。</p><ul><li><code>dfs</code>代码<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++">function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; dfs = [&amp;](<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> k)-&gt;<span class="hljs-type">int</span><br>&#123;<br><span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> flag = k | i &lt;&lt; <span class="hljs-number">1</span> | j &lt;&lt; <span class="hljs-number">20</span>;<br><span class="hljs-keyword">if</span> (!cache.<span class="hljs-built_in">count</span>(flag))<br>&#123;<br><span class="hljs-keyword">if</span> (j == <span class="hljs-number">1</span>)<br>&#123;<br>cache[flag] = (cards[i] % <span class="hljs-number">2</span> == k ? cards[i] : <span class="hljs-built_in">dfs</span>(i - <span class="hljs-number">1</span>, j, k));<br><span class="hljs-keyword">return</span> cache[flag];<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>cache[flag] = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">dfs</span>(i - <span class="hljs-number">1</span>, j, k), <span class="hljs-built_in">dfs</span>(i - <span class="hljs-number">1</span>, j - <span class="hljs-number">1</span>, (k + cards[i]) % <span class="hljs-number">2</span>) ? <span class="hljs-built_in">dfs</span>(i - <span class="hljs-number">1</span>, j - <span class="hljs-number">1</span>, (k + cards[i]) % <span class="hljs-number">2</span>) + cards[i] : <span class="hljs-number">0</span>);<br><span class="hljs-keyword">return</span> cache[flag];<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">return</span> cache[flag];<br>&#125;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><p>虽然使用dp不会成功，但已经写出来记忆化递归了，那顺便把dp也写出来吧。</p><p>dp的核心递归公式和dfs一致，只是要把dfs替换成dp数组，然后边界条件是<code>j=1</code>时的情况，然后就是dp要从<code>i=1</code>开始计算所以奇数和偶数情况在每次循环时都要计算。最终结果为<code>dp[0 | (n - 1) &lt;&lt; 1 | cnt &lt;&lt; 20]</code></p><ul><li>dp代码<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>&#123;<br>dp[(cards[i] % <span class="hljs-number">2</span>) | i &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">20</span>] = <span class="hljs-built_in">max</span>(cards[i], dp[(cards[i] % <span class="hljs-number">2</span>) | (i - <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">20</span>]);<br>dp[((cards[i] + <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>) | i &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">20</span>] = dp[((cards[i] + <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>) | (i - <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">20</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">2</span>; j &lt;= i + <span class="hljs-number">1</span> &amp;&amp; j &lt;= cnt; j++)<br>&#123;<br>dp[<span class="hljs-number">0</span> | i &lt;&lt; <span class="hljs-number">1</span> | j &lt;&lt; <span class="hljs-number">20</span>] = <span class="hljs-built_in">max</span>(dp[<span class="hljs-number">0</span> | (i - <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-number">1</span> | j &lt;&lt; <span class="hljs-number">20</span>], dp[cards[i] % <span class="hljs-number">2</span> | (i - <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-number">1</span> | (j - <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-number">20</span>] ? dp[cards[i] % <span class="hljs-number">2</span> | (i - <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-number">1</span> | (j - <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-number">20</span>] + cards[i] : <span class="hljs-number">0</span>);<br>dp[<span class="hljs-number">1</span> | i &lt;&lt; <span class="hljs-number">1</span> | j &lt;&lt; <span class="hljs-number">20</span>] = <span class="hljs-built_in">max</span>(dp[<span class="hljs-number">1</span> | (i - <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-number">1</span> | j &lt;&lt; <span class="hljs-number">20</span>], dp[(cards[i] + <span class="hljs-number">1</span>) % <span class="hljs-number">2</span> | (i - <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-number">1</span> | (j - <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-number">20</span>] ? dp[(cards[i] + <span class="hljs-number">1</span>) % <span class="hljs-number">2</span> | (i - <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-number">1</span> | (j - <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-number">20</span>] + cards[i] : <span class="hljs-number">0</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>然后查看提示，发现要使用贪心和排序。经过思考后决定先将数组排序，然后将其分为奇偶两个数组。然后在进行判断。</p><p>在进行判断时要分为多种情况讨论，<code>s_max</code>,<code>d_max1</code>,<code>d_max2</code>分别为最大两个奇数的和，最大的偶数以及最大两个偶数的和。<code>s_pos</code>,<code>d_pos</code>分别表示还未使用的最大奇数下标以及还未使用的最大偶数下标。</p><p>以下是几种需要讨论的情况</p><ul><li><code>cnt</code>为1时，需要判断是否还有偶数</li><li>只剩两个偶数时</li><li>只剩一个偶数时</li><li>没有偶数时</li><li>偶数数量大于2时（这是一般情况，只需要比较<code>s_max</code>,<code>d_max1</code>,<code>d_max2</code>的大小进行判断即可）</li></ul><p>其他特殊情况需要综合还未使用的奇数数量，还未使用的偶数数量以及还有多少的数没有选择。</p><ul><li>奇偶数组的判断代码<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span> (cnt)<br>&#123;<br><span class="hljs-type">int</span> s_max = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> d_max1 = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> d_max2 = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (cnt == <span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-keyword">if</span> (d_pos &gt;= <span class="hljs-number">0</span>)<br>&#123;<br>ans += d[d_pos];<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>ans = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (s_pos &gt; <span class="hljs-number">0</span>)<br>&#123;<br>s_max = s[s_pos] + s[s_pos - <span class="hljs-number">1</span>];<br>&#125;<br><span class="hljs-keyword">if</span> (d_pos &gt; <span class="hljs-number">1</span>)<br>&#123;<br>d_max1 = d[d_pos];<br>d_max2 = d[d_pos] + d[d_pos - <span class="hljs-number">1</span>];<br><span class="hljs-keyword">if</span> (d_max1 &gt;= s_max)<br>&#123;<br>ans += d_max1;<br>d_pos--;<br>cnt--;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (d_max2 &gt; s_max)<br>&#123;<br>ans += d_max2;<br>d_pos -= <span class="hljs-number">2</span>;<br>cnt -= <span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>ans += s_max;<br>s_pos -= <span class="hljs-number">2</span>;<br>cnt -= <span class="hljs-number">2</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (d_pos == <span class="hljs-number">1</span>)<br>&#123;<br>d_max1 = d[d_pos];<br>d_max2 = d[d_pos] + d[d_pos - <span class="hljs-number">1</span>];<br><span class="hljs-keyword">if</span> (s_max &gt; d_max2)<br>&#123;<br>ans += s_max;<br>s_pos -= <span class="hljs-number">2</span>;<br>cnt -= <span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (d_max1 &gt;= s_max)<br>&#123;<br>ans += d_max1;<br>d_pos--;<br>cnt--;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">if</span> ((cnt - <span class="hljs-number">2</span>) % <span class="hljs-number">2</span>)<br>&#123;<br>ans += d_max1;<br>d_pos--;<br>cnt--;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">if</span> (cnt - <span class="hljs-number">2</span> &lt;= s_pos + <span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = s_pos; i &gt;= s_pos + <span class="hljs-number">3</span> - cnt; i--)<br>&#123;<br>ans += s[i];<br>&#125;<br>ans += d_max2;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (d_pos == <span class="hljs-number">0</span>)<br>&#123;<br>d_max1 = d[d_pos];<br><span class="hljs-keyword">if</span> (s_max &gt; d_max1)<br>&#123;<br>ans += s_max;<br>s_pos -= <span class="hljs-number">2</span>;<br>cnt -= <span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">if</span> ((cnt - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>)<br>&#123;<br><span class="hljs-keyword">if</span> (cnt &lt;= s_pos + <span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = s_pos; i &gt;= s_pos + <span class="hljs-number">1</span> - cnt; i--)<br>&#123;<br>ans += s[i];<br>&#125;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">if</span> (cnt - <span class="hljs-number">1</span> &lt;= s_pos + <span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = s_pos; i &gt;= s_pos + <span class="hljs-number">2</span> - cnt; i--)<br>&#123;<br>ans += s[i];<br>&#125;<br>ans += d_max1;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (d_pos &lt; <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">if</span> (cnt % <span class="hljs-number">2</span>)<br>&#123;<br>ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">if</span> (cnt &lt;= s_pos + <span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = s_pos; i &gt;= s_pos + <span class="hljs-number">1</span> - cnt; i--)<br>&#123;<br>ans += s[i];<br>&#125;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>这个思路比较容易想到，但其特殊情况很多，需要经过很多判断，非常烦人，很容易出现一望一些特殊情况。</p><p>查看题解后，发现了一个更加简单的方法，不需要考虑很多特殊情况。</p><p>首先将数组进行排序，然后取最大的<code>cnt</code>个数相加得到<code>ans</code>.然后根据<code>ans</code>进行判断</p><ul><li>如果<code>ans</code>为偶数，则直接返回</li><li>如果<code>ans</code>为奇数，则有以下两种情况<ul><li><code>ans</code>减去已使用过数中的最小偶数，加上一个未使用过的最大奇数</li><li><code>ans</code>减去已使用过数中的最小奇数，加上一个未使用过的最大偶数<br>将以上两种情况得到的值取最大即为<code>ans</code>，但以上两种不一定都会出现，需要进行判断，如果两种情况都不出现，则没有符合条件的结果，返回0.</li></ul></li></ul><p>以下代码中<code>pos1</code>,<code>pos2</code>分别为已使用过的数中最小奇数和最小偶数的下标，<code>pos3</code>,<code>pos4</code>分别为未使用过的数中最大奇数和最大偶数的下标。如果下标值为<code>n</code>,则表明不存在这样的数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= n  - cnt; i--)<br>&#123;<br><span class="hljs-keyword">if</span> (cards[i] % <span class="hljs-number">2</span>)<br>&#123;<br>pos1 = i;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>pos2 = i;<br>&#125;<br>ans += cards[i];<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span> - cnt; i &gt;= <span class="hljs-number">0</span>; i--)<br>&#123;<br><span class="hljs-keyword">if</span> ((cards[i] % <span class="hljs-number">2</span>) &amp;&amp; pos3 == n)<br>&#123;<br>pos3 = i;<br>&#125;<br><span class="hljs-keyword">if</span> (!(cards[i] % <span class="hljs-number">2</span>) &amp;&amp; pos4 == n)<br>&#123;<br>pos4 = i;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (ans % <span class="hljs-number">2</span>)<br>&#123;<br><span class="hljs-keyword">if</span> (pos3 == n)<br>&#123;<br><span class="hljs-keyword">if</span> (pos4 == n)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>ans = ans - cards[pos1] + cards[pos4];<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">if</span> (pos4 == n)<br>&#123;<br><span class="hljs-keyword">if</span> (pos2 != n)<br>&#123;<br>ans = ans - cards[pos2] + cards[pos3];<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">if</span> (pos2 != n)<br>&#123;<br>ans = <span class="hljs-built_in">max</span>(ans - cards[pos2] + cards[pos3], ans - cards[pos1] + cards[pos4]);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>ans = ans - cards[pos1] + cards[pos4];<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本来是一道简单题，但是想的太多，反而使其变得更加复杂。（ps:这是第二次打完这段文字，第一次没有保存，导致多花了一个小时，真是糟糕的一天）</p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快速幂</title>
    <link href="/2024/07/31/%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    <url>/2024/07/31/%E5%BF%AB%E9%80%9F%E5%B9%82/</url>
    
    <content type="html"><![CDATA[<h1 id="leetcode"><a href="#leetcode" class="headerlink" title="leetcode"></a>leetcode</h1><ul><li>快速幂</li></ul><p>普通的幂运算每次只只乘上一次，比如计算<code>pow(2,64)</code>就要循环64次。这样的时间复杂度很高，而快速幂则可以减少运算的复杂度</p><p>对于快速幂算法而言，<code>pow(x,y)</code>,我们可以把<code>y</code>看成一个二进制数,然后我们以次求出<code>pow(x,1)</code>,<code>pow(x,2)</code>,<code>pow(x,4)</code>,…以此类推，然后我们查看<code>y</code>对应二进制数的每一位，如果为0,则当前数就要乘上<code>x</code>对应二进制的幂。</p><p>例如<code>y=13</code>,它对应的二进制数为<code>1101</code>,则<code>pow(x,13)</code>就为<code>pow(x,8)</code>、<code>pow(x,4)</code>、<code>pow(x,1)</code>之和。</p><ul><li>算法对应的C++代码</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fastpow</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> ans = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (y) <br>&#123;<br><span class="hljs-keyword">if</span> (y &amp; <span class="hljs-number">1</span>) <br>&#123;<br>ans *= x;<br>&#125;<br>x *= x;<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>关于取余的一些技巧 </p><ul><li>加法取余</li></ul><p><code>(a+b)%c=((a%c)+(b%c))%c</code></p><p>适合与很多个数相加时，最后的很大，无法存下，就将取余操作放在每次相加后，避免数据过大溢出</p><ul><li>乘法取余</li></ul><p><code>(a*b)%c=((a*c)+(b*c))%c</code></p><p>同样也是为了避免相乘后数据溢出，就将取余操作放在每次相乘之后</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>快速幂</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
